#ifndef PALPART_H
#define PALPART_H

#include <iostream>		// cout, endl 
#include <vector>
#include <string>

#define COUT std::cout
#define ENDL std::endl
#define STRING std::string
#define VECTOR std::vector

/********************************************
* Function Name  : isPalindrome
* Pre-conditions : STRING strPal
* Post-conditions: bool
* 
* Determines if the string is a palindrome or not 
********************************************/
bool isPalindrome(STRING strPal){
	
	if(strPal.length() == 0){
		return true;
	}
	
	for(long unsigned int i = 0; i < strPal.length(); i++){
		if(strPal[i] != strPal[strPal.length() - i - 1])
			return false;
	}
	
	return true;
}


/********************************************
* Function Name  : testPalindrome
* Pre-conditions : STRING strPal
* Post-conditions: none
* 
* A function to test all cases of isPalindrome 
********************************************/
void testPalindrome(STRING strPal){
	
	COUT << "The string '" << strPal << "' is ";
	
	if(!isPalindrome(strPal))
		COUT << "not ";
	
	COUT << "a palindrome." << ENDL;
}

/********************************************
* Function Name  : isPalinPart
* Pre-conditions : STRING strPal, int low, int high
* Post-conditions: bool
* 
* Calculates if a substring of the string is a
* Palindrom from low to high 
********************************************/
bool isPalinPart(STRING strPal, long unsigned int low, long unsigned int high){
	
	if(strPal.length() == 0)
		return true;

    while (low < high) 
    { 
        if (strPal[low] != strPal[high]) 
            return false; 
		
        low++; high--; 
    } 
    return true; 	
	
}


/********************************************
* Function Name  : allPalPartUtil
* Pre-conditions : VECTOR< VECTOR< STRING > >& allPart, 
				   VECTOR< STRING >& currPart, 
				   STRING str, size_t start, size_t n
* Post-conditions: none
*  
********************************************/
void allPalPartUtil(VECTOR< VECTOR< STRING > >& allPart, 
					VECTOR< STRING >& currPart, 
					STRING str, size_t start, size_t n) 
{ 
    // If 'start' has reached len 
    if (start >= n) 
    { 
        allPart.push_back(currPart); 
        return; 
    } 
  
    // Pick all possible ending points for substrings 
    for (long unsigned int i = start; i < n; i++) 
    { 
		// COUT << start << "\t" << i << "\t" << i-start+1 << "\t\t" << str.substr(start, i-start+1) << "\t\t\t\t";
        // If substring str[start..i] is palindrome 
        if (isPalinPart(str, start, i)) 
        { 
			//COUT << " is a Palindrome!" << ENDL;
	
            // Add the substring to result 
            currPart.push_back(str.substr(start, i-start+1)); 
  
            // Recur for remaining remaining substring 
            allPalPartUtil(allPart, currPart, str, i+1, n); 
              
            // Remove substring str[start..i] from current  
            // partition 
            currPart.pop_back(); 
        } 
		/*else{
			COUT << ENDL;
		}*/
    } 
} 
  
/********************************************
* Function Name  : allPalPartitions
* Pre-conditions : STRING str
* Post-conditions: none
* 
* Gets all the Palindromic Partitions of the
* input string 
********************************************/
void allPalPartitions(STRING str) 
{ 

	COUT << "Input string = '" << str << "'" << ENDL << "Palindromic Partitions: " << ENDL;
	
    size_t n = str.length(); 
  
    // To Store all palindromic partitions 
    VECTOR< VECTOR<STRING> > allPartitions; 
  
    // To store current palindromic partition 
    VECTOR<STRING> currPartition;  
  
    // Call recursive function to generate all partitions and store in allPartitions 
    allPalPartUtil(allPartitions, currPartition, str, 0, n); 
  
    // Print all partitions generated by above call 
	COUT << "Total Partition Combinations = " << allPartitions.size() << ENDL;
    for (size_t i=0; i < allPartitions.size(); i++ ) 
    { 
        for (size_t j=0; j<allPartitions[i].size(); j++) 
            COUT << allPartitions[i][j] << " "; 
        COUT << "\n"; 
    } 
	
	COUT << "------------" << ENDL;
} 

#endif